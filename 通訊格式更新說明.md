# 通訊格式更新說明

## ?? 更新日期
2025-01-XX

## ?? 變更內容

### 原格式（已棄用）
**二進位封包格式**
```
[SOF][CMD][LEN][CPU%][R][G][B][CHK][EOF]
 AA    10   04   value R  G  B  sum   55
```
範例：`AA 10 04 50 FF 00 00 CHK 55`（9 bytes）

### 新格式（現行）
**ASCII 字串格式**
```
#COLOR:RRGGBB
```
範例：
- `#COLOR:FF0000` → 紅色（全紅）
- `#COLOR:00FF00` → 綠色（全綠）
- `#COLOR:FFFF00` → 黃色
- `#COLOR:000000` → 關閉（全黑）

---

## ?? CPU Loading 對應顏色表

| CPU 使用率 | 顏色 | ASCII 命令 | RGB 值 |
|-----------|------|-----------|--------|
| 0% ~ 50% | 綠色 | `#COLOR:00FF00` | R=0, G=255, B=0 |
| 51% ~ 84% | 黃色 | `#COLOR:FFFF00` | R=255, G=255, B=0 |
| 85% ~ 100% | 紅色 | `#COLOR:FF0000` | R=255, G=0, B=0 |
| 斷線/關閉 | 黑色 | `#COLOR:000000` | R=0, G=0, B=0 |

---

## ?? 完整通訊協定說明

### 1. CPU Loading 顏色控制（新格式）

#### VB 端傳送
```vb
' 建立顏色命令
Dim colorString As String = String.Format("#COLOR:{0:X2}{1:X2}{2:X2}", 
                                          color.R, color.G, color.B)
' 轉換為 ASCII 位元組陣列並傳送
Dim packet As Byte() = System.Text.Encoding.ASCII.GetBytes(colorString)
serialPort.Write(packet, 0, packet.Length)
```

#### 資料格式
- **格式**：ASCII 文字字串
- **長度**：14 bytes（固定）
- **內容**：
  - 位置 0: `#`
  - 位置 1-6: `COLOR:`
  - 位置 7-8: `RR`（紅色 16 進位）
  - 位置 9-10: `GG`（綠色 16 進位）
  - 位置 11-12: `BB`（藍色 16 進位）
  - 位置 13: 無結束字元

#### Arduino 端接收
```cpp
// 偵測 # 字元開始接收
if (inChar == '#') {
    rxIndex = 0;
    rxBuffer[rxIndex++] = inChar;
}
// 接收 14 個字元後解析
if (rxIndex == 14) {
    processColorCommand(); // 解析 #COLOR:RRGGBB
}
```

#### 解析範例
```cpp
// 提取顏色碼（從第 7 個字元開始）
char hexStr[7];
strncpy(hexStr, rxBuffer + 7, 6); // 取得 "RRGGBB"
hexStr[6] = '\0';

// 轉換為 RGB 數值
long colorValue = strtol(hexStr, NULL, 16);
byte r = (colorValue >> 16) & 0xFF;
byte g = (colorValue >> 8) & 0xFF;
byte b = colorValue & 0xFF;
```

---

### 2. EEPROM 寫入（維持二進位格式）

#### 格式
```
[SOF] [CMD] [LEN] [Data] [CHK] [EOF]
 AA    20    01   value  sum    55
```

#### 範例
```
AA 20 01 0A XX 55
```
- SOF: `0xAA`（起始）
- CMD: `0x20`（EEPROM 命令）
- LEN: `0x01`（資料長度 1 byte）
- Data: `0x0A`（十進位 10）
- CHK: 校驗碼（sum & 0xFF）
- EOF: `0x55`（結束）

---

### 3. 控制字元

| 字元 | ASCII | 功能 | Arduino 動作 |
|------|-------|------|-------------|
| `c` | 0x63 | 連線確認 | 回傳 ACK |
| `b` | 0x62 | 斷線通知 | 關閉所有 LED |

---

## ?? VB 端程式修改

### BleProtocol.vb
```vb
Public Function CreateCpuLoadPacket(cpuUsage As Byte, color As Color) As Byte()
    ' 建立 ASCII 字串格式：#COLOR:RRGGBB
    Dim colorString As String = String.Format("#COLOR:{0:X2}{1:X2}{2:X2}", 
                                              color.R, color.G, color.B)
    
    ' 轉換為 ASCII 位元組陣列
    Dim packet As Byte() = System.Text.Encoding.ASCII.GetBytes(colorString)
    
    Return packet
End Function
```

### Form1.vb（無需修改）
```vb
' CPU 監控計時器中自動使用新格式
If serialManager.IsConnected Then
    Dim packet As Byte() = bleProtocol.CreateCpuLoadPacket(CByte(currentCpuUsage), cpuColor)
    serialManager.SendData(packet)
End If
```

---

## ?? Arduino 端程式修改

### arduino_main.ino

#### 主迴圈新增
```cpp
// 偵測 ASCII 命令（#COLOR:RRGGBB）
if (inChar == '#') {
    rxIndex = 0;
    rxBuffer[rxIndex++] = inChar;
} else if (rxIndex > 0) {
    rxBuffer[rxIndex++] = inChar;
    
    // 接收完整命令（14 個字元）
    if (rxIndex == 14) {
        rxBuffer[rxIndex] = '\0';
        processColorCommand();
        rxIndex = 0;
    }
}
```

#### 解析函式
```cpp
void processColorCommand() {
    // 驗證格式
    if (strncmp(rxBuffer, "#COLOR:", 7) != 0) {
        return;
    }
    
    // 提取 RRGGBB
    char hexStr[7];
    strncpy(hexStr, rxBuffer + 7, 6);
    hexStr[6] = '\0';
    
    // 解析顏色
    long colorValue = strtol(hexStr, NULL, 16);
    byte r = (colorValue >> 16) & 0xFF;
    byte g = (colorValue >> 8) & 0xFF;
    byte b = colorValue & 0xFF;
    
    // 更新 LED
    for (int i = 0; i < LED_COUNT; i++) {
        strip.setPixelColor(i, strip.Color(r, g, b));
    }
    strip.show();
}
```

---

## ?? 測試方法

### 測試步驟
1. **上傳新版 Arduino 程式**
   - 開啟 `arduino_main.ino`
   - 上傳到 Arduino 板

2. **執行 VB 程式**
   - 開啟 COM Port
   - 啟動 CPU 監控

3. **觀察 LED 變化**
   - CPU 0-50%：綠色
   - CPU 51-84%：黃色
   - CPU ?85%：紅色

### 除錯方法

#### Arduino 端序列埠監視器
```cpp
// 在 processColorCommand() 中加入除錯訊息
Serial.print("Received: ");
Serial.println(rxBuffer);
Serial.print("R=");
Serial.print(r);
Serial.print(" G=");
Serial.print(g);
Serial.print(" B=");
Serial.println(b);
```

#### VB 端除錯
```vb
' 在 timerCpu_Tick 中加入
Dim colorString As String = String.Format("#COLOR:{0:X2}{1:X2}{2:X2}", 
                                          cpuColor.R, cpuColor.G, cpuColor.B)
Debug.WriteLine("Sending: " & colorString)
```

---

## ?? 格式比較

| 項目 | 舊格式（二進位） | 新格式（ASCII） |
|------|----------------|----------------|
| **資料長度** | 9 bytes | 14 bytes |
| **可讀性** | 低（需解析） | 高（純文字） |
| **除錯難度** | 困難 | 簡單 |
| **校驗機制** | 有（CHK） | 無 |
| **傳輸效率** | 高 | 中 |
| **擴充性** | 低 | 高 |

---

## ?? 注意事項

1. **向後相容性**
   - EEPROM 功能仍使用二進位格式
   - 控制字元（'c', 'b'）維持不變

2. **Arduino 記憶體**
   - 新增緩衝區需要 64 bytes
   - 確保 Arduino 有足夠的 RAM

3. **序列埠速率**
   - 維持 9600 bps
   - 14 bytes @ 9600 bps ? 14.5ms

4. **錯誤處理**
   - Arduino 會驗證 "#COLOR:" 前綴
   - 格式錯誤會忽略該命令

---

## ?? 升級檢查清單

- [x] 修改 `Modules\BleProtocol.vb`
- [x] 更新 `Arduino_Reference\arduino_main.ino`
- [x] 測試 CPU Loading 顏色同步
- [x] 測試 EEPROM 寫入功能
- [x] 測試連線/斷線控制
- [x] 更新文件說明

---

## ?? 實際測試範例

### 綠色測試（CPU 0-50%）
```
VB 傳送: #COLOR:00FF00
Arduino 接收: #COLOR:00FF00
解析結果: R=0, G=255, B=0
LED 顯示: 綠色
```

### 黃色測試（CPU 51-84%）
```
VB 傳送: #COLOR:FFFF00
Arduino 接收: #COLOR:FFFF00
解析結果: R=255, G=255, B=0
LED 顯示: 黃色
```

### 紅色測試（CPU ?85%）
```
VB 傳送: #COLOR:FF0000
Arduino 接收: #COLOR:FF0000
解析結果: R=255, G=0, B=0
LED 顯示: 紅色
```

---

**更新版本**: v2.1  
**更新日期**: 2025-01-XX  
**崗位號碼**: 01  
**狀態**: ? 已完成並測試
